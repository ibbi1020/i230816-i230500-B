================================================================================
                         SIMPLELANG LANGUAGE GRAMMAR
                  CS4031 Compiler Construction - Assignment 01
================================================================================

LANGUAGE NAME: SimpleLang
FILE EXTENSION: .lang
TEAM: i230816-i230500-B

================================================================================
1. LEXICAL SPECIFICATIONS
================================================================================

1.1 KEYWORDS (12 total, case-sensitive, all lowercase)
-----------------------------------------------------
start       - Program entry point
finish      - Program termination
loop        - Loop construct
condition   - Conditional statement  
declare     - Variable declaration
output      - Print output
input       - Read input  
function    - Function definition
return      - Return from function
break       - Exit loop
continue    - Skip to next iteration
else        - Alternative branch

REGEX: (start|finish|loop|condition|declare|output|input|function|return|break|continue|else)


1.2 IDENTIFIERS
-----------------------------------------------------
- MUST start with uppercase letter (A-Z)
- Followed by lowercase letters (a-z), digits (0-9), or underscores (_)
- Maximum length: 31 characters
- Case-sensitive

REGEX: [A-Z][a-z0-9_]{0,30}

VALID EXAMPLES:
  X, MyVariable, Counter123, First_name, Student_id

INVALID EXAMPLES:
  lowercase (starts with lowercase)
  _Variable (starts with underscore)  
  123Number (starts with digit)


1.3 INTEGER LITERALS
-----------------------------------------------------
- Optional sign (+ or -)
- One or more digits (0-9)

REGEX: [+-]?[0-9]+

EXAMPLES: 123, -456, +789, 0, -1


1.4 FLOATING-POINT LITERALS
-----------------------------------------------------
- Optional sign
- Integer part + decimal point + 1-6 decimal digits
- Optional exponent (e/E with optional sign and digits)

REGEX: [+-]?[0-9]+\.[0-9]{1,6}([eE][+-]?[0-9]+)?

EXAMPLES: 3.14159, -2.5, +0.001, 1.5e10, 3.14E-5


1.5 STRING LITERALS
-----------------------------------------------------
- Enclosed in double quotes ("")
- Cannot span multiple lines
- Supports escape sequences: \", \\, \n, \t, \r

REGEX: "([^"\\\n]|\\["\\ntr])*"

EXAMPLES:
  "Hello, World!"
  "She said \"Hi\""
  "Path: C:\\Users\\Documents"
  "Line1\nLine2"


1.6 CHARACTER LITERALS
-----------------------------------------------------
- Enclosed in single quotes ('')
- Single character or escape sequence
- Supports escape sequences: \', \\, \n, \t, \r

REGEX: '([^'\\\n]|\\['\\ntr])'

EXAMPLES: 'A', '5', '\n', '\'', '\\'


1.7 BOOLEAN LITERALS
-----------------------------------------------------
- Only two values: true, false
- Case-sensitive (must be lowercase)

REGEX: (true|false)

EXAMPLES: true, false


1.8 ARITHMETIC OPERATORS
-----------------------------------------------------
+     Addition
-     Subtraction
*     Multiplication
/     Division
%     Modulo
**    Exponentiation (highest precedence)

REGEX: (\*\*|[+\-*/%])


1.9 RELATIONAL OPERATORS
-----------------------------------------------------
==    Equal to
!=    Not equal to
<     Less than
>     Greater than
<=    Less than or equal to
>=    Greater than or equal to

REGEX: (==|!=|<=|>=|<|>)


1.10 LOGICAL OPERATORS
-----------------------------------------------------
&&    Logical AND
||    Logical OR
!     Logical NOT

REGEX: (&&|\|\||!)


1.11 ASSIGNMENT OPERATORS
-----------------------------------------------------
=     Simple assignment
+=    Add and assign
-=    Subtract and assign
*=    Multiply and assign
/=    Divide and assign

REGEX: (\+=|-=|\*=|/=|=)


1.12 INCREMENT/DECREMENT OPERATORS
-----------------------------------------------------
++    Increment by 1
--    Decrement by 1

REGEX: (\+\+|--)

Can be used as prefix or postfix: X++ or ++X


1.13 PUNCTUATORS
-----------------------------------------------------
(     Left parenthesis
)     Right parenthesis
{     Left brace
}     Right brace
[     Left bracket
]     Right bracket
,     Comma
;     Semicolon
:     Colon

REGEX: [(){}\[\],;:]


1.14 SINGLE-LINE COMMENTS
-----------------------------------------------------
- Start with ##
- Continue until end of line
- Everything after ## is ignored

REGEX: ##[^\n]*

EXAMPLES:
  ## This is a comment
  declare X = 100  ## Inline comment


1.15 MULTI-LINE COMMENTS
-----------------------------------------------------
- Start with #*
- End with *#
- Can span multiple lines
- Cannot be nested

REGEX: #\*([^*]|\*+[^*#])*\*+#

EXAMPLES:
  #* This is a
     multi-line comment *#


1.16 WHITESPACE
-----------------------------------------------------
- Spaces, tabs, carriage returns, newlines
- Used as token separators
- Preserved inside string and character literals
- Otherwise ignored during tokenization

REGEX: [ \t\r\n]+


================================================================================
2. PATTERN MATCHING PRIORITY ORDER
================================================================================

The scanner must recognize tokens in the following priority order (highest to
lowest) to ensure correct tokenization:

1. Multi-line comments (#*...*#)
2. Single-line comments (##...)
3. Multi-character operators (**,==,!=,<=,>=,&&,||,+=,-=,*=,/=,++,--)
4. Keywords (start, finish, loop, etc.)
5. Boolean literals (true, false)
6. Identifiers ([A-Z][a-z0-9_]*)
7. Floating-point literals (X.Y format)
8. Integer literals
9. String literals ("...")
10. Character literals ('.')
11. Single-character operators and punctuators
12. Whitespace

This order prevents ambiguities:
- "==" recognized as single token, not two "=" tokens
- "true" recognized as boolean, not identifier "T" + identifier "rue"
- "3.14" recognized as float, not integer "3" + "." + integer "14"


================================================================================
3. TOKEN FORMAT
================================================================================

All tokens are represented in the following format:

<TOKEN_TYPE, "lexeme", Line: X, Col: Y>

Where:
- TOKEN_TYPE: Enum value from TokenType.java
- lexeme: The actual text matched from input
- Line: Line number (1-based)
- Col: Column number (1-based)

EXAMPLES:
<KEYWORD_DECLARE, "declare", Line: 5, Col: 1>
<IDENTIFIER, "Counter", Line: 5, Col: 9>
<OP_ASSIGN, "=", Line: 5, Col: 17>
<INTEGER_LITERAL, "100", Line: 5, Col: 19>


================================================================================
4. SYMBOL TABLE
================================================================================

The scanner maintains a symbol table for all identifiers:

FIELDS:
- Name: Identifier string
- Type: Always "IDENTIFIER"
- First Line: Line of first occurrence
- First Column: Column of first occurrence
- Frequency: Total number of occurrences

EXAMPLE OUTPUT:
Name                 Type            First Line First Col  Frequency
--------------------------------------------------------------------------------
Counter              IDENTIFIER      Line: 5    Col: 9    Frequency: 5
Maximum              IDENTIFIER      Line: 10   Col: 13   Frequency: 3


================================================================================
5. ERROR HANDLING
================================================================================

The scanner detects and reports the following lexical errors:

5.1 INVALID CHARACTERS
- Any character not part of the language alphabet
- Examples: @, $, ~, `, ^, &, |, \
- Error format: [ERROR] INVALID_CHARACTER at Line X, Col Y: 'C' - Invalid 
  character 'C' (ASCII: N)

5.2 UNTERMINATED STRING LITERALS
- String not closed before end of line or file
- Error format: [ERROR] UNTERMINATED_STRING at Line X, Col Y: '"...' - String 
  literal not terminated

5.3 UNTERMINATED CHARACTER LITERALS
- Character literal not closed
- Error format: [ERROR] UNTERMINATED_CHAR at Line X, Col Y: ''...' - Character 
  literal not terminated

5.4 INVALID ESCAPE SEQUENCES
- Backslash followed by invalid character in string/char literal
- Valid escapes: \", \', \\, \n, \t, \r
- Error format: [ERROR] INVALID_ESCAPE at Line X, Col Y: '\x' - Invalid escape 
  sequence

5.5 UNCLOSED MULTI-LINE COMMENTS
- Comment started with #* but never closed with *#
- Error format: [ERROR] UNCLOSED_COMMENT at Line X, Col Y: '#*...' - Multi-line 
  comment not closed

5.6 IDENTIFIER TOO LONG
- Identifier exceeds maximum length (31 characters)
- Error format: [ERROR] IDENTIFIER_TOO_LONG at Line X, Col Y: 'name' - 
  Identifier exceeds maximum length of 31 characters (length: N)

ERROR RECOVERY:
- Scanner continues after errors
- Invalid characters skipped
- Error tokens generated for tracking
- Total error count reported


================================================================================
6. STATISTICS OUTPUT
================================================================================

The scanner produces the following statistics:

- Total Tokens: Count of all tokens (excluding whitespace/comments)
- Lines Processed: Total lines scanned
- Comments Removed: Number of comment tokens (single-line + multi-line)
- Token Count by Type: Breakdown of each token type with count
- Unique Identifiers: Count of distinct identifiers
- Total Identifier Occurrences: Sum of all identifier frequencies


================================================================================
7. CONTEXT-FREE GRAMMAR (CFG)
================================================================================

7.1 PROGRAM STRUCTURE
-----------------------------------------------------
Program         → start StmtList finish

StmtList        → Stmt StmtList | ε

Stmt            → DeclStmt
                | AssignStmt
                | OutputStmt
                | InputStmt
                | ConditionStmt
                | LoopStmt
                | FunctionDef
                | ReturnStmt
                | BreakStmt
                | ContinueStmt


7.2 DECLARATIONS
-----------------------------------------------------
DeclStmt        → declare IDENTIFIER = Expr
                | declare IDENTIFIER [ Expr ]


7.3 ASSIGNMENTS
-----------------------------------------------------
AssignStmt      → IDENTIFIER = Expr
                | IDENTIFIER += Expr
                | IDENTIFIER -= Expr
                | IDENTIFIER *= Expr
                | IDENTIFIER /= Expr
                | IDENTIFIER [ Expr ] = Expr
                | IDENTIFIER ++
                | IDENTIFIER --
                | ++ IDENTIFIER
                | -- IDENTIFIER


7.4 INPUT/OUTPUT
-----------------------------------------------------
OutputStmt      → output Expr

InputStmt       → input IDENTIFIER


7.5 CONDITIONAL STATEMENTS
-----------------------------------------------------
ConditionStmt   → condition Expr StmtList
                | condition Expr StmtList else StmtList


7.6 LOOPS
-----------------------------------------------------
LoopStmt        → loop Expr StmtList


7.7 FUNCTIONS
-----------------------------------------------------
FunctionDef     → function IDENTIFIER ( ParamList ) StmtList

ParamList       → IDENTIFIER , ParamList
                | IDENTIFIER
                | ε

ReturnStmt      → return Expr


7.8 EXPRESSIONS
-----------------------------------------------------
Expr            → LogicalOrExpr

LogicalOrExpr   → LogicalAndExpr || LogicalOrExpr
                | LogicalAndExpr

LogicalAndExpr  → EqualityExpr && LogicalAndExpr
                | EqualityExpr

EqualityExpr    → RelationalExpr == EqualityExpr
                | RelationalExpr != EqualityExpr
                | RelationalExpr

RelationalExpr  → AdditiveExpr < RelationalExpr
                | AdditiveExpr > RelationalExpr
                | AdditiveExpr <= RelationalExpr
                | AdditiveExpr >= RelationalExpr
                | AdditiveExpr

AdditiveExpr    → MultiplicativeExpr + AdditiveExpr
                | MultiplicativeExpr - AdditiveExpr
                | MultiplicativeExpr

MultiplicativeExpr → ExponentialExpr * MultiplicativeExpr
                   | ExponentialExpr / MultiplicativeExpr
                   | ExponentialExpr % MultiplicativeExpr
                   | ExponentialExpr

ExponentialExpr → UnaryExpr ** ExponentialExpr
                | UnaryExpr

UnaryExpr       → ! UnaryExpr
                | - UnaryExpr
                | + UnaryExpr
                | PrimaryExpr

PrimaryExpr     → INTEGER_LITERAL
                | FLOAT_LITERAL
                | STRING_LITERAL
                | CHAR_LITERAL
                | BOOLEAN_LITERAL
                | IDENTIFIER
                | IDENTIFIER [ Expr ]
                | IDENTIFIER ( ArgList )
                | ( Expr )

ArgList         → Expr , ArgList
                | Expr
                | ε


7.9 CONTROL FLOW
-----------------------------------------------------
BreakStmt       → break

ContinueStmt    → continue


================================================================================
8. OPERATOR PRECEDENCE AND ASSOCIATIVITY
================================================================================

Precedence Level | Operators           | Associativity | Description
-----------------------------------------------------------------------------
1 (highest)      | **                  | Right         | Exponentiation
2                | ! - + (unary)       | Right         | Unary operators
3                | * / %               | Left          | Multiplicative
4                | + -                 | Left          | Additive
5                | < > <= >=           | Left          | Relational
6                | == !=               | Left          | Equality
7                | &&                  | Left          | Logical AND
8 (lowest)       | ||                  | Left          | Logical OR


================================================================================
9. SAMPLE PROGRAM
================================================================================

## Factorial Calculator
start
    declare Num = 5
    declare Result = 1
    declare Counter = 1
    
    ## Calculate factorial using loop
    loop Counter <= Num
        Result *= Counter
        Counter++
    
    output "Factorial of "
    output Num
    output " is "
    output Result
    
    ## Function-based factorial
    function Factorial(N)
        condition N <= 1
            return 1
        else
            return N * Factorial(N - 1)
    
    declare Fact2 = Factorial(6)
    output "Factorial of 6 is "
    output Fact2
finish


================================================================================
10. IMPLEMENTATION NOTES
================================================================================

10.1 DFA-BASED RECOGNITION
- Each token category has a minimized DFA
- Longest match principle applied
- Backtracking when necessary 
- State transition tables stored in ManualScanner.java

10.2 LINE AND COLUMN TRACKING
- Line counter incremented on '\n'
- Column counter incremented on each character
- Column reset to 1 at start of new line
- Positions tracked before consuming token

10.3 WHITESPACE HANDLING
- Whitespace acts as token separator
- Removed during pre-processing (except in strings)
- Multiple consecutive whitespace treated as single separator

10.4 COMMENT HANDLING
- Comments removed during scanning
- Not included in final token stream
- Comment count tracked for statistics

10.5 ERROR RECOVERY
- Invalid characters: skip and continue
- Unterminated strings: report but accept what was scanned
- Continue scanning after each error
- All errors collected and reported at end


================================================================================
END OF GRAMMAR SPECIFICATION
================================================================================
